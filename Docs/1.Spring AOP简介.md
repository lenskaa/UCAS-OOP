# 一. Spring AOP 概述

## 1.1 什么是面向切面编程（AOP）

面向切面的程序设计（Aspect-oriented programming，AOP，又译作面向方面的程序设计、剖面导向程序设计）是计算机科学中的一种程序设计思想，旨在将横切关注点与业务主体进行进一步分离，以提高程序代码的模块化模块化程度。

面向切面的程序设计将代码逻辑切分为不同的模块（关注点（Concern），一段特定的逻辑功能）。几乎所有的编程思想都涉及代码功能的分类，将各个关注点封装成独立的抽象模块（如函数、过程、模块、类以及方法等），后者又可供进一步实现、封装和重写。部分关注点“横切”程序代码中的数个模块，即在多个模块中都有出现，它们即被称作横切关注点（Cross-cutting concerns, Horizontal concerns）。

```
https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1
```

为了更加形象地理解，我们可以举一个例子。在很多业务代码中，都会包含许多重复的非核心业务功能（例如日志、授权等功能）。这些功能重复出现在不同模块中，既使模块变得庞大，又增加了维护难度：

![AOP1](D:\NutShell\Object_Oriented\UCAS-OOP\Docs\AOP1.jpg)

这时我们可以将这些重复的逻辑单独提取出来形成模块，在需要使用时“织入”代码中即可：

![AOP2](D:\NutShell\Object_Oriented\UCAS-OOP\Docs\AOP2.jpg)

这样做可以大大的减轻代码的维护量，并且可以在完全不改变原有代码的情况下，加入新的功能。这样的编程方式，即为面向方面编程。

```
图片：https://www.zhihu.com/search?type=content&q=AOP%20OOP
```

## 1.2 什么是 Spring AOP

AOP 实现的关键在于 AOP 框架自动创建的 AOP 代理，主要分为静态代理和动态代理。 Spring AOP 即为动态代理实现 AOP 的一个框架。Spring AOP 中的动态代理主要有两种方式：JDK 动态代理和 CGLIB 动态代理。

```
https://segmentfault.com/a/1190000018120725
```

## 1.3 AOP 的相关术语

类似于 OOP 中继承，实现等诸多术语，AOP 也有其对应的术语与概念。为了更好的理解 AOP 的实现，我们需要先了解这些基本术语。

* **切面（Aspect）**
   切面是一个横切关注点的模块化，一个切面能够包含同一个类型的不同增强方法，比如说事务处理和日志处理可以理解为两个切面。切面由切入点和通知组成，它既包含了横切逻辑的定义，也包括了切入点的定义。 Spring AOP就是负责实施切面的框架，它将切面所定义的横切逻辑织入到切面所指定的连接点中。

* **目标对象(Target)**
  目标对象指将要被增强的对象，即包含主业务逻辑的类对象。或者说是被一个或者多个切面所通知的对象。

* **连接点(JoinPoint)**

  程序执行过程中明确的点，如方法的调用或特定的异常被抛出。连接点由两个信息确定：

  - 方法(表示程序执行点，即在哪个目标方法)
  - 相对点(表示方位，即目标方法的什么位置，比如调用前，后等)

  简单来说，连接点就是被拦截到的程序执行点，因为Spring只支持方法类型的连接点，所以在Spring中连接点就是被拦截到的方法。

* **切入点(PointCut)**

  切入点是对连接点进行拦截的条件定义。切入点表达式如何和连接点匹配是AOP的核心，Spring缺省使用AspectJ切入点语法。 
   一般认为，所有的方法都可以认为是连接点，但是我们并不希望在所有的方法上都添加通知，而切入点的作用就是提供一组规则(使用 AspectJ pointcut expression language 来描述) 来匹配连接点，给满足规则的连接点添加通知。

* **通知(Advice)**

  通知是指拦截到连接点之后要执行的代码，包括了“around”、“before”和“after”等不同类型的通知。Spring AOP框架以拦截器来实现通知模型，并维护一个以连接点为中心的拦截器链。

* **织入(Weaving)**

  织入是将切面和业务逻辑对象连接起来, 并创建通知代理的过程。织入可以在编译时，类加载时和运行时完成。在编译时进行织入就是静态代理，而在运行时进行织入则是动态代理。

* **增强器(Adviser)**

  Advisor是切面的另外一种实现，能够将通知以更为复杂的方式织入到目标对象中，是将通知包装为更复杂切面的装配器。Advisor由切入点和Advice组成。
  Advisor这个概念来自于Spring对AOP的支撑，在AspectJ中是没有等价的概念的。Advisor就像是一个小的自包含的切面，这个切面只有一个通知。切面自身通过一个Bean表示，并且必须实现一个默认接口（AbstractPointcutAdvisor）。

```
https://segmentfault.com/a/1190000018120725
```

## 1.4 Advice 的类型

概括而言，满足 pointcut 规则的 joinpoint 会被添加相应的 advice 操作，advice 操作添加的位置取决于 advice 操作的类型：

- **before advice**

  在 join point 前被执行的 advice。虽然 before advice 是在 join point 前被执行, 但是它并不能够阻止 join point 的执行, 除非发生了异常(即我们在 before advice 代码中, 不能人为地决定是否继续执行 join point 中的代码)

- **after return advice**

  在一个 join point 正常返回后执行的 advice；

- **after throwing advice**

  当一个 join point 抛出异常后执行的 advice；

- **after(final) advice**

  无论一个 join point 是正常退出还是发生了异常, 都会被执行的 advice；

- **around advice**

  在 join point 前和 joint point 退出后都执行的 advice。