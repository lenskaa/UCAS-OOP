# 二. 主要功能分析与建模

Spring AOP 主要负责在不改变源码的前提下，往一个方法的某处插入一个代码块。这个功能的实现过程较长，本文将选择这一流程的第一步 —— `Advisor` 实例的生成进行分析。

## 2.1 Spring AOP 功能示例

为了理解 Spring AOP 的功能，我们从一个示例开始：

```java
//声明这是一个组件
@Component
//声明这是一个切面Bean
@Aspect
public class ServiceAspect {

    //配置切入点,该方法无方法体,主要为方便同类中其他方法使用此处配置的切入点
    @Pointcut("execution(* com.lcl.ooplearn.spring.aop.service..*(..))")
    public void aspect() {
    }

    /*
     * 配置前置通知,使用在方法aspect()上注册的切入点
     * 同时接受JoinPoint切入点对象,可以没有该参数
     */
    @Before("aspect()")
    public void before(JoinPoint joinPoint) {
        //通知
        ...
    }

}
```

我们使用 `@Aspect` 定义了一个切面，切面中包含了切入点和通知。通知的类型为 Before Advice，因此在实际运行过程中，`com.lcl.ooplearn.spring.aop.service` 包下的所有类的所有方法执行前都将执行该通知。

Spring AOP 执行时，Spring 框架将生成 `Advisor` 实例，可以是 `@Aspect`，`@Async` 等注解生成的实例，也可以是程序员自定义的 `AbstractAdvisor` 子类的实例，然后 Spring 框架将根据Advisor实例生成代理对象。最后，执行到指定方法时，Spring 方法将执行 `Advisor` 实例中的 `Advice` 逻辑。接下来，我们针对 `Advisor` 实例的生成这一功能进行分析。

## 2.2 Advisor 实例的生成过程

Spring AOP 中  `Advisor` 实例的生成由两个类负责，`AbstractAdvisorAutoProxyCreator` 和 `AnnotationAwareAspectJAutoProxyCreator`，其中后者是前者的子类。生成  `Advisor` 实例的入口函数为 `findCandidateAdvisors` 函数。

* `AbstractAdvisorAutoProxyCreator` 类：

```java
protected List<Advisor> findCandidateAdvisors() {
		Assert.state(this.advisorRetrievalHelper != null, "No BeanFactoryAdvisorRetrievalHelper available");
		return this.advisorRetrievalHelper.findAdvisorBeans();
```

`advisorRetrievalHelper` 中的 `findAdvisorBeans` 可以通过 `BeanFactory` 的 `getBean` 获取所有类型为`Advisor`的实例。`AbstractAdvisorAutoProxyCreator` 的 `findCandidateAdvisors` 函数可以直接获取 Spring 容器中的`Advisor`实例。

* `AnnotationAwareAspectJAutoProxyCreator` 类：

```java
@Override
	protected List<Advisor> findCandidateAdvisors() {
		// Add all the Spring advisors found according to superclass rules.
		List<Advisor> advisors = super.findCandidateAdvisors();
		// Build Advisors for all AspectJ aspects in the bean factory.
		if (this.aspectJAdvisorsBuilder != null) {
			advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());
		}
		return advisors;
	}
```

`AnnotationAwareAspectJAutoProxyCreator` 类中的  `findCandidateAdvisors` 函数调用了父类函数。除此之外，还为 Aspectj 中的切面（即 `@Aspect`）构造 `Advisor`，生成 `InstantiationModelAwarePointcutAdvisor` 实例，这一功能是通过调用 `buildAspectJAdvisors` 实现的。

接下来我们看看 `buildAspectJAdvisors` 函数，它包含在 `BeanFactoryAspectJAdvisorsBuilder` 类中。

* `BeanFactoryAspectJAdvisorsBuilder` 类：

```java
public List<Advisor> buildAspectJAdvisors() {
	List<String> aspectNames = this.aspectBeanNames;

	if (aspectNames == null) {
		synchronized (this) {
			aspectNames = this.aspectBeanNames;
				if (aspectNames == null) {
				List<Advisor> advisors = new ArrayList<>();
				aspectNames = new ArrayList<>();
				String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
							this.beanFactory, Object.class, true, false);
				for (String beanName : beanNames) {
					if (!isEligibleBean(beanName)) {
						continue;
					}
					// We must be careful not to instantiate beans eagerly as in this case they
					// would be cached by the Spring container but would not have been weaved.
					Class<?> beanType = this.beanFactory.getType(beanName, false);
					if (beanType == null) {
						continue;
					}
					if (this.advisorFactory.isAspect(beanType)) {
						aspectNames.add(beanName);
						AspectMetadata amd = new AspectMetadata(beanType, beanName);
						if (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) {
							MetadataAwareAspectInstanceFactory factory =
									new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName);
							List<Advisor> classAdvisors = this.advisorFactory.getAdvisors(factory);
							if (this.beanFactory.isSingleton(beanName)) {
								this.advisorsCache.put(beanName, classAdvisors);
							}
							else {
								this.aspectFactoryCache.put(beanName, factory);
							}
							advisors.addAll(classAdvisors);
						}
						else {
							// Per target or per this.
							if (this.beanFactory.isSingleton(beanName)) {
								throw new IllegalArgumentException("Bean with name '" + beanName +
										"' is a singleton, but aspect instantiation model is not singleton");
							}
							MetadataAwareAspectInstanceFactory factory =
									new PrototypeAspectInstanceFactory(this.beanFactory, beanName);
							this.aspectFactoryCache.put(beanName, factory);
							advisors.addAll(this.advisorFactory.getAdvisors(factory));
						}
					}
				}
				this.aspectBeanNames = aspectNames;
				return advisors;
			}
		}
	}
...
```

此为 `buildAspectJAdvisors` 执行时的第一种情况，`aspectNames` 为null时，需要进行第一次初始化，在这一过程中生成切面名称列表 `aspectBeanNames` 和要返回的 `Advisor` 列表，并且将生成的 `Advisor` 实例放置到`advisorsCache`中。具体的运行过程：

1. 首先使用 `BeanFactoryUtils` 获取了 `BeanFactory` 中所有的 `BeanName`，然后进而使用 `BeanFactory` 获取所有的 `Bean` 实例。

2. 遍历 `Bean` 实例，通过 `ReflectiveAspectJAdvisorFactory` 的 `isAspect` 函数判断该实例是否为切面实例，也就是被 `@Aspect` 注解修饰的实例。

3. 如果是，则使用 `ReflectiveAspectJAdvisorFactory`，根据切面实例的定义来生成对应的多个 `Advisor` 实例，并且将其加入到 `advisorsCache` 中。

* `BeanFactoryAspectJAdvisorsBuilder` 类：

```java
...
	if (aspectNames.isEmpty()) {
		return Collections.emptyList();
	}
	List<Advisor> advisors = new ArrayList<>();
	for (String aspectName : aspectNames) {
		List<Advisor> cachedAdvisors = this.advisorsCache.get(aspectName);
		if (cachedAdvisors != null) {
			advisors.addAll(cachedAdvisors);
		}
		else {
			MetadataAwareAspectInstanceFactory factory = this.aspectFactoryCache.get(aspectName);
			advisors.addAll(this.advisorFactory.getAdvisors(factory));
		}
	}
	return advisors;
}
```

此为 `buildAspectJAdvisors` 执行时的第二种情况，即已经初始化后再次调用，此时遍历 `aspectNames`，从 `advisorsCache ` 取出对应的 `Advisor` 实例，或者从 `advisorsCache` 取出 `Advisor` 对应的工厂类对象，再次生成 `Advisor` 实例。

除此之外，`ReflectiveAspectJAdvisorFactory `的 `getAdvisors  `函数会获取 `@Aspect` 修饰的实例中所有没有被 `@Pointcut `修饰的方法，然后调用 `getAdvisor `函数，并且将这些方法作为参数。

* `ReflectiveAspectJAdvisorFactory` 类

```java
@Override
@Nullable
public Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,
		int declarationOrderInAspect, String aspectName) {

	validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());

	AspectJExpressionPointcut expressionPointcut = getPointcut(
			candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());
	if (expressionPointcut == null) {
		return null;
	}
	return new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,
			this, aspectInstanceFactory, declarationOrderInAspect, aspectName);
}

@Nullable
private AspectJExpressionPointcut getPointcut(Method candidateAdviceMethod, Class<?> candidateAspectClass) {
	AspectJAnnotation<?> aspectJAnnotation =
				AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);
	if (aspectJAnnotation == null) {
		return null;
	}

	AspectJExpressionPointcut ajexp =
			new AspectJExpressionPointcut(candidateAspectClass, new String[0], new Class<?>[0]);
	ajexp.setExpression(aspectJAnnotation.getPointcutExpression());
	if (this.beanFactory != null) {
		ajexp.setBeanFactory(this.beanFactory);
	}
	return ajexp;
}
```

`InstantiationModelAwarePointcutAdvisorImpl` 的构造函数会依据不同的注解（不同的通知类型）生成不同的 `Advice` 通知。

```java
public InstantiationModelAwarePointcutAdvisorImpl(AspectJExpressionPointcut declaredPointcut,
			Method aspectJAdviceMethod, AspectJAdvisorFactory aspectJAdvisorFactory,
			MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {

	this.declaredPointcut = declaredPointcut;
	this.declaringClass = aspectJAdviceMethod.getDeclaringClass();
	this.methodName = aspectJAdviceMethod.getName();
	this.parameterTypes = aspectJAdviceMethod.getParameterTypes();
	this.aspectJAdviceMethod = aspectJAdviceMethod;
	this.aspectJAdvisorFactory = aspectJAdvisorFactory;
	this.aspectInstanceFactory = aspectInstanceFactory;
	this.declarationOrder = declarationOrder;
	this.aspectName = aspectName;

	if (aspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {
		// Static part of the pointcut is a lazy type.
		Pointcut preInstantiationPointcut = Pointcuts.union(
				aspectInstanceFactory.getAspectMetadata().getPerClausePointcut(), this.declaredPointcut);

		// Make it dynamic: must mutate from pre-instantiation to post-instantiation state.
		// If it's not a dynamic pointcut, it may be optimized out
		// by the Spring AOP infrastructure after the first evaluation.
		this.pointcut = new PerTargetInstantiationModelPointcut(
				this.declaredPointcut, preInstantiationPointcut, aspectInstanceFactory);
		this.lazy = true;
	}
	else {
		// A singleton aspect.
		this.pointcut = this.declaredPointcut;
		this.lazy = false;
		this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut);
	}
}
```

 至此，Spring AOP 就获取了容器中所有的 `Advisor` 实例，下一步在每个实例初始化完成后，根据这些 `Advisor `的 `Pointcut` 切入点进行筛选，获取合适的 `Advisor` 实例，并生成代理实例。